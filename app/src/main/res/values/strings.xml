<resources>
    <string name="app_name">DataStructuresAndAlgorithms</string>
    <string name="title_home">Home</string>
    <string name="title_dashboard">Dashboard</string>
    <string name="title_notifications">Notifications</string>
    <string name="title_activity_main2">Main2Activity</string>
    <string name="tab_text_1">Tab 1</string>
    <string name="tab_text_2">Tab 2</string>

    <string-array name="bubble">
        <item>Sorts an array by swapping the adjacent elements if they are in the wrong order</item>
        <item>Iterates Through array and see if succeeding number if less than the current number</item>
        <item>If the current number is less than the succeeding number the two numbers swap</item>
        <item>After each iteration the next number starting from the back is sorted</item>
    </string-array>
    <string-array name="insertion">
        <item>A simple sorting algorithm that builds the final sorted array one item at a time</item>
        <item>Starting with the second item in the array for as long as the number to the left is less than the current number swap current number with the number on its left</item>
        <item>This is done for each preceding number in array until we reach the end of the array</item>
    </string-array>
    <string-array name="merge">
        <item>Sorts an array by swapping the adjacent elements if they are in the wrong order</item>
        <item>The algorithm starts by splitting the array half then split those halves in half until there is until each subarray is size one</item>
        <item>Each pair of halves is sorted then sorts as they merge with each other</item>
        <item>This method can be looked at as similar to divide and conquer but they sort as they conquer</item>
    </string-array>
    <string-array name="quick">
        <item>Picks an element as pivot and partitions the given array around the picked pivot</item>
        <item>Select a pivot of your choosing</item>
        <item>Put all items lower than the pivot to its left and all items larger than the pivot to its right, the pivot is now sorted</item>
        <item>Repeat the above step for the right side of the pivot as a sub array and do the same for the right side of the pivot</item>
    </string-array>
    <string-array name="heap">
        <item>First the maximum element is found and then placed at the end, the the process is repeated for each remaining element</item>
        <item>Puts array in heap</item>
        <item>Change heap to max heap (A max heap states that a parent node is always greater than or equal to its child node)</item>
        <item>Take the root and swap it with the last node in the heap</item>
        <item>Remove or ignore that node as part of the heap because it has just been sorted</item>
        <item>Since the array is already in a heap, repeat the rest of the steps to sorted the rest of the nodes in the heap or the rest of the elements in the array</item>
    </string-array>
    <string-array name="selection">
        <item></item>
        <item>Starting from the beginning of the array, sets the next item in the array to be the minimum value in the array</item>
        <item>Iterates through array to find a lower value then the minimum value and swaps it with the old minimum value making it the new minimum value</item>
        <item>Each preceding item in the array will be sorted starting from the front after each iteration</item>
    </string-array>
    <string-array name="for_loop">
        <item>A form of iteration where a block code is repeated where the “for” statement contains where the loop starts, where the loop ends and how long the loop will be running for. </item>
        <item>Starts by typing “for”</item>
        <item>Enters the starting point of the loop followed by a semicolon</item>
        <item>Enters the condition that will keep the loop repeating followed by a semicolon</item>
        <item>Enters the incrementer</item>
        <item>A completed “for loop” statement</item>
    </string-array>
    <string-array name="while_loop">
        <item>A form of iteration where a block of code is repeated for as long as the condition in the while statement is true</item>
        <item>Starts by typing “while”</item>
        <item>Enters the condition that will keep the loop going, the loop will exit when that condition becomes false</item>
        <item>A completed “while loop” statement</item>
    </string-array>
    <string-array name="do_while_loop">
        <item>A form of iteration where a block of code is executed before the condition in the while statement is checked. The same block of code will then be repeated for as long as the condition in the while statement is true. </item>
        <item>Starts by typing “do”</item>
        <item>Enters the block of code to be repeated</item>
        <item>Followed by the word “while”</item>
        <item>Enters the condition that will keep the loop going, the loop will exit when that condition becomes false</item>
        <item>A completed “do while loop” statement</item>
    </string-array>
    <string-array name="linear_search">
        <item>An iterative algorithm that finds the position of a target value within a list, with the list being usually unsorted.</item>
        <item>Does not need the list to be sorted</item>
        <item>Starting from the leftmost item in the list</item>
        <item>Sequentially look at every element in that list to see if it is the element we are looking for</item>
        <item>If we have found the element then return the index of the element</item>
        <item>If we have not found the element then return -1</item>
    </string-array>
    <string-array name="binary_search">
        <item>An algorithm that finds the position of a target value within a sorted array by cutting the array in half until the item is found or until we cannot split anymore. This would mean that the item is not found.</item>
        <item>Needs to be a sorted list</item>
        <item>Starts by comparing the middle element of the list to the element being searched for</item>
        <item>If the element is equal to the middle element then we have found our element</item>
        <item>If the element being searched for is greater than the middle element, the algorithm then looks at the left side of the list</item>
        <item>If the element is less, the algorithm looks at the right side of the list</item>

        <item>Repeat the process of splitting until we find our element</item>
        <item>If we split down to one element and our item is not found then the element does not exist in the list</item>
    </string-array>

    <string-array name="string_replace">
        <item>A method used to search a string for a specified value, or a regular expression, and returns a new string where the
        specified values are replaced.</item>
    </string-array>

    <string-array name="string_concat">
        <item>A method used to return a string replacing all the old char or CharSequence to new char or CharSequence.</item>
    </string-array>

    <string-array name="inOrder">
        <item>A method used to traverse a tree by first visiting the left node, followed by root and finally right node.</item>
    </string-array>

    <string-array name="preOrder">
        <item>A method used to traverse a tree by first visiting the root, followed by the left subtree and the right subtree.</item>
    </string-array>
    <string-array name="postOrder">
        <item>A method used to traverse a tree by first visiting the left subtree, followed by the right subtree.</item>
    </string-array>
    <string-array name="hash_function">
        <item>A hash function is any function that can be used to map data of arbitrary size to fixed-size values. The values returned by a hash function are called hash values, hash codes, digests, or simply hashes. The values are used to index a fixed-size table called a hash table</item>
        <item>A well written hash function does a good job at minimizing collisions</item>
        <item>A Collision is when two different strings for example, have the same hash values</item>
        <item>A Simple hash function would be to get the unicode for  each character in the string</item>
        <item>This does not help the fact that the different permutations of the same string will have the same hash value</item>
        <item>We can optimize this method or function by simply multiple each char value in the string by a constant to the power of the position of the character in the string</item>
    </string-array>

    <!-- TODO: Remove or change this placeholder text -->
    <string name="hello_blank_fragment">Hello blank fragment</string>
</resources>
